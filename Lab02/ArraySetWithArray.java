package Lab02;import java.util.Arrays;/** * A class that implements the ADT set by using a resizable array. * The array is never full. * * @author Maciek Bieszczad * @version 12/28/2016 */public class ArraySetWithArray<T extends Comparable<? super T>> implements SetInterface<T>{    private T[] arrayOfSetEntries;    private int numberOfEntries;    private static final int DEFAULT_CAPACITY = 3; // Initial capacity of array    private boolean initialized = false;    private static final int MAX_CAPACITY = 100;    /**     * Creates an empty array whose initial capacity is 3.     */    public ArraySetWithArray()    {        //TODO Project2 done        this(DEFAULT_CAPACITY);    } // end default constructor    /**     * Creates an empty array having a given initial capacity.     *     * @param capacity The integer capacity desired.     */    public ArraySetWithArray(int capacity)    {        //TODO Project2 done        checkCapacity(capacity);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] tempBag = (T[]) new Comparable<?>[capacity]; // Unchecked cast        this.arrayOfSetEntries = tempBag;        this.numberOfEntries = 0;        this.initialized = true;    } // end constructor    /**     * Creates an array containing given entries.     *     * @param contents An array of objects.     */    public ArraySetWithArray(T[] contents)    {        //TODO Project2 done        checkCapacity(contents.length);        this.arrayOfSetEntries = Arrays.copyOf(contents, contents.length);        this.numberOfEntries = contents.length;        this.initialized = true;    } // end constructor    /**     * Adds a new entry to this array, avoiding duplicates.     *     * @param newEntry The object to be added as a new entry.     * @return True if the addition is successful, or false if not.     */    public boolean add(T newEntry)    {        //TODO Project2 done        checkInitialization();        if (isArrayFull())        {            ensureCapacity();        }        this.arrayOfSetEntries[this.numberOfEntries] = newEntry;        this.numberOfEntries++;        return true;    } // end add    /**     * Retrieves all entries that are in this array.     *     * @return A newly allocated array of all the entries.     */    public T[] toArray()    {        //TODO Project2 done        checkInitialization();        // The cast is safe because the new array contains null entries.        @SuppressWarnings("unchecked")        T[] result = (T[]) new Comparable<?>[this.numberOfEntries]; // Unchecked cast        for (int index = 0; index < this.numberOfEntries; index++)        {            result[index] = this.arrayOfSetEntries[index];        }        return result;    } // end toArray    /**     * Sees whether this array is empty.     *     * @return True if this array is empty, or false if not.     */    public boolean isEmpty()    {        //TODO Project2 done        return this.numberOfEntries == 0;    } // end isEmpty    /**     * Gets the number of entries currently in this array.     *     * @return The integer number of entries currently in the array.     */    public int getCurrentSize()    {        //TODO Project2 done        return this.numberOfEntries;    } // end getCurrentSize    /**     * Tests whether this array contains a given entry.     *     * @param anEntry The entry to locate.     * @return True if the array contains anEntry, or false if not.     */    public boolean contains(T anEntry)    {        //TODO Project2 done        checkInitialization();        return getIndexOf(anEntry) > -1; // or >= 0    } // end contains    // Locates a given entry within the array bag.    // Returns the index of the entry, if located,    // or -1 otherwise.    // Precondition: checkInitialization has been called.    private int getIndexOf(T anEntry)    {        int where = -1;        boolean stillLooking = true;        for (int index = 0; stillLooking && (index < this.numberOfEntries); index++)        {            if (anEntry.equals(this.arrayOfSetEntries[index]))            {                stillLooking = false;                where = index;            }        }        return where;    } // end getIndexOf    /**     * Removes all entries from this array.     */    public void clear()    {        while (!isEmpty())            remove();    } // end clear    /**     * Removes one unspecified entry from this bag.     *     * @return Either the removed entry if the removal     * was successful, or null if not.     */    public T remove()    {        //TODO Project2 done        checkInitialization();        T result = removeEntry(this.numberOfEntries - 1);        return result;    } // end remove    /**     * Removes one occurrence of a given entry from this array.     *     * @param anEntry The entry to be removed.     * @return True if the removal was successful, or null if not.     */    public boolean removeElement(T anEntry)    {        //TODO Project2 done        checkInitialization();        int index = getIndexOf(anEntry);        T result = removeEntry(index);        return anEntry.equals(result);    } // end removeElement    // Removes and returns the array entry at a given index.    // If no such entry exists, returns null.    private T removeEntry(int givenIndex)    {        //TODO Project2 done        T result = null;        if (!isEmpty() && (givenIndex >= 0))        {            result = this.arrayOfSetEntries[givenIndex]; // Entry to remove            this.numberOfEntries--;            this.arrayOfSetEntries[givenIndex] = this.arrayOfSetEntries[this.numberOfEntries]; // Replace entry to remove with last entry            this.arrayOfSetEntries[this.numberOfEntries] = null; // Remove reference to last entry        }        return result;    } // end removeEntry    // Displays a set.    public void displaySet()    {        if (this.numberOfEntries > 0)        {            System.out.print("There are " + this.numberOfEntries + " element(s): ");            for (int index = 0; index < this.numberOfEntries; index++)            {                System.out.print(this.arrayOfSetEntries[index] + " ");            }            System.out.println();        }        else            System.out.println("The bag is empty");    } // end displaySet    // Returns true if the array bag is full, or false if not.    private boolean isArrayFull()    {        return this.numberOfEntries >= this.arrayOfSetEntries.length;    } // end isArrayFull    // Doubles the size of the array bag.    // Precondition: checkInitialization has been called.    private void ensureCapacity()    {        int newLength = 2 * this.arrayOfSetEntries.length;        checkCapacity(newLength);        this.arrayOfSetEntries = Arrays.copyOf(this.arrayOfSetEntries, newLength);    } // end ensureCapacity    // Throws an exception if the client requests a capacity that is too large.    private void checkCapacity(int capacity)    {        if (capacity > MAX_CAPACITY)            throw new IllegalStateException("Attempt to create a bag whose capacity exceeds " +                    "allowed maximum of " + MAX_CAPACITY);    } // end checkCapacity    // Throws an exception if receiving object is not initialized.    private void checkInitialization()    {        if (!this.initialized)            throw new SecurityException("Uninitialized object used " +                    "to call an ArrayBag method.");    } // end checkInitialization} // end ArraySetWithArray